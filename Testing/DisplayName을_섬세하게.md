테스트 코드를 작성할 때, 다음과 같이 행위를 기준으로 메서드 명을 작성해도 테스트의 목적을 표현하기에는 한계가 존재한다.

```java
@Test
void add_test() {
	...
}
```

이 테스트 코드의 목적성을 분명하게 나타내기 위해, JUnit5에 추가된 `@DisplayName` 어노테이션을 사용할 수 있다.

# @DisplayName()

어노테이션에 String 값을 넣어 

> 테스트 메서드가 어떤 목적을 가지고 어떤 역할을 하는지를 명시해 줄 수 있다.
> 

```java
@Test
@DisplayName("음료 1잔 추가 테스트")
void add_test() {
	...
}
```

*JUnit4에서는 한글로 메서드명을 작성하기도 한다.*

여기서 두 `@DisplayName`을 한 번 비교해보자.

```java
1. @DisplayName("음료 1잔 추가 테스트")
2. @DisplayName("음료 1잔을 추가하면 주문 목록에 담긴다.")
```

비즈니스 로직을 모르는 사람이 테스트 코드만 봤을 때, 테스트 코드를 이해하는데 더 명확한 방법은 당연히 2번의 방법이다. 

따라서, `@DisplayName`을 좀 더 효율적으로 사용하는 방법은

1. 명사의 나열 보다는 **문장**으로 표현하는 것이다.
    - A면 B다.
    - A이면 B가 아니고, C다.
        - 어떤 상태 변화가 있었는지에 대한 결과까지 명시할 수 있다.

1. 테스트 행위에 대한 **결과**까지 진술하는 것이다.
    - “음료를 1잔 추가할 수 있다.” ⇒ “음료를 1잔 추가하면 ***주문 목록에 담긴다.***”
2. **도메인 용어**를 사용해 한층 추상화된 내용을 담는 것이다.
    - “특정 시간 이전에 주문을 생성하면 실패한다.” ⇒ “***영업 시작 시간*** 이전에는 주문을 생성할 수 없다.”
        - “특정 시간” 이라는 것은 해당 애플리케이션에서 사용하는 용어가 아닌, 일반적인 용어이다. 하지만, “영업 시작 시간”이라는 것은 해당 애플리케이션에서 사용하는 시간을 나타내는 도메인 용어이기 때문에 더 추상화된 내용을 표현할 수 있다.
    - 즉, 메서드 자체의 관점보다 **도메인 정책 관점**으로 표현하는 것이 좋다.
3. 테스트의 현상을 중점으로 기술하지 않아야 한다.
    - 위의 “실패한다.” 라는 표현은 테스트의 내용과 무관하다.
    - 성공, 실패는 테스트에 대한 결과이다. 테스트하고자 하는   무관한 단어이다.